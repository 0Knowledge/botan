/*************************************************
* BLUM BLUM SHUB Source File                     *
* (C) 2007 FlexSecure GmbH / Manuel Hartl        *
*************************************************/

#include <botan/bbs.h>
#include <botan/lookup.h>
#include <botan/randpool.h>
#include <botan/bit_ops.h>
#include <botan/bigintfuncs.h>
#include <algorithm>
#include <iostream>



namespace Botan
  {

  /*************************************************
  * Generate a buffer of random bytes              *
  *************************************************/
  void BBS::randomize(byte bytes[], u32bit length) throw(PRNG_Unseeded)
  {
    if(!is_seeded())
      {
        throw PRNG_Unseeded(name());
      }

    // number of bits to be generated
    int numBits = length * 8;
    // bitmask of next bit to be set
    int aktResultBit = 1;
    // generated byte
    u32bit aktResultByte = 0;
    // bit to be copied
    int aktSourceBit = 0;
    // number of bits processed
    int aktResult = 0;

    // ensure that all parameters are generated
    if (!parametersGenerated)
      {
        generateParameters();
      }

    // clear first byte
    bytes[0] = 0;
    do
      {
        // if source-bit is set
        if (x.get_bit(aktSourceBit++))
          {
            // set corresponding bit in result-vector
            bytes[aktResultByte] += aktResultBit;
          }
        // shift left bitmask by one
        aktResultBit = aktResultBit << 1;

        // if bitsPerRound is reached
        if (aktSourceBit == bitsPerRound)
          {
            // reset counter,
            aktSourceBit = 0;
            // and generate new seed (sqare-mod-generator)
            x = (x*x)%n;
          }

        // if a whole byte has been generated
        if (aktResultBit == 256)
          {
            // reset bitmask
            aktResultBit = 1;
            // and switch to next byte
            aktResultByte++;
            // if one more byte is left to do
            if (aktResultByte < length)
              {
                // clear it.
                bytes[aktResultByte] = 0;
              }
          }
        // next bit
        aktResult++;
      } // while still some bits are to be generated
    while (aktResult < numBits);
  }

  /*************************************************
  * Refill the internal state                      *
  *************************************************/
  void BBS::update_buffer()
{}


  /*************************************************
  * Add entropy to internal state                  *
  *************************************************/
  void BBS::add_randomness(const byte data[], u32bit length)
  {
    prng->add_entropy(data, length);
    MemoryVector<byte> for_rand;
    for_rand.set(data, length);
    if (prng->is_seeded())
      {
        prng->randomize(for_rand, length);

        if (isSeeded) // if the object is already seeded
          {
            // modify the seed by xor-ing the parameter to the seed,
            BigInt b = BigInt(for_rand,length);
            seed = exlusive_or(seed,b) % LCG_MODULUS;
          }
        else
          { // otherwise
            // set it explicitly
            seed = BigInt(for_rand,length)%LCG_MODULUS;
            isSeeded = true;
          }
      }
    parametersGenerated = false;
  }

  /*************************************************
  * Check if the the PRNG is seeded                *
  *************************************************/
  bool BBS::is_seeded() const
    {
      //return isSeeded;
      return isSeeded && prng->is_seeded();
    }

  /*************************************************
  * Clear memory of sensitive data                 *
  *************************************************/
  void BBS::clear() throw()
  {
    prng->clear();
  }

  /*************************************************
  * Return the name of this type                   *
  *************************************************/
  std::string BBS::name() const
    {
      return "BBS";
    }

  /*************************************************
  * SHA1PRNG Constructor                           *
  *************************************************/
  BBS::BBS(SharedPtrConverter<RandomNumberGenerator> prng_ptr)
  {
    prng = (prng_ptr.get_shared().get() ? prng_ptr.get_shared() : std::tr1::shared_ptr<RandomNumberGenerator>(new Randpool));
    LCG_A = BigInt("7129718823414295026033436596773772714578900265841170538826");
    LCG_B = BigInt("675276940120214627441986171104851609581303133674533034328917");
    LCG_MODULUS = BigInt("805464911080722516417453601008791849136329615762701082177197");
    seed = BigInt("0000000000000000000000000000000000");

    BIG2=BigInt(2);
    BIG3=BigInt(3);
    BIG4=BigInt(4);
    BIG5=BigInt(5);
    BIG7=BigInt(7);
    BIG11=BigInt(11);
    BIG13=BigInt(13);
    BIG17=BigInt(17);
    BIG19=BigInt(19);
    BIG23=BigInt(23);
    BIG27=BigInt(27);

    isSeeded = false;
    // the parameters p, q, x have not been generated yet
    parametersGenerated = false;

    // generate the object that will do seeding
    //   seedGenerator = new SeedGenerator();

    // calculate the number of bits to be generated per iteration
    bitsPerRound = 0;
    for (int i = 0; i < 32; i++)
      {
        if ((SECURITY_PARAMETER & (1 << i)) != 0)
          {
            bitsPerRound = i;
          }
      }
  }

  /*************************************************
  * SHA1PRNG Destructor                            *
  *************************************************/
  BBS::~BBS()
  {}

  /**
   * This method implements a linear congruential generator to extend the seed
   * of 200 Bits to a size needed with the BBS generator. Theese bits are used
   * to generate the parameters p, q, and x. The bits generated by the lcg are
   * not visible from outside. Hence lcg does not have to be a
   * cryrographically secure generator.
   *
   * @param bitLength -
   *                number of bits to be generated
   * @result an array containing the generated bits. Depending on (bitLength
   *         mod 8), the first byte will be padded with zero bits.
   */
  void BBS::lcg(u32bit bitLength, byte result[])
  {
    int i, j;
    // create an array big enough to contain all bits
    u32bit resultLen = (bitLength + 7) / 8;
    // leftover bits
    int leftBits = bitLength % 8;
    // generate all full bytes

    for (i = resultLen - 1; i >= (int)(resultLen - bitLength / 8); i--)
      {

        result[i] = 0;
        for (j = 1; j < 256; j <<= 1)
          {
            // always output the lsb
            if (seed.get_bit(0))
              {
                result[i] |= j;
              }
            // and then change the seed
            seed = (LCG_A+(LCG_B*seed))%LCG_MODULUS;
          }
      }

    // if needed
    if (i == 0)
      {
        // generate a byte with the leftover bits
        for (j = 0; j < leftBits; j++)
          {
            if (seed.get_bit(0))
              {
                result[i] |= 1 << j;
              }
            else
              {
                result[i] &= 255 - (1 << j);
              }
            seed = (LCG_A+(LCG_B*seed))%LCG_MODULUS;
          }

        // and pad it with zero bits
        for (j = leftBits; j < 8; j++)
          {
            result[i] &= 255 - (1 << j);
          }
      }
  }

  void BBS::generateParameters()
  {
    // bitlength of p
    int pBL;
    // bitlength of q
    int qBL;
    // used to test if small factors exist
    int zmod3, zmod5, zmod7, zmod11, zmod13, zmod17, zmod19, zmod23;
    int add
      ;

    // determine bit lengths of p and q
    if ((SECURITY_PARAMETER & 1) == 1)
      {
        pBL = 1 + SECURITY_PARAMETER / 2;
        qBL = pBL;
      }
    else
      {
        pBL = SECURITY_PARAMETER / 2;
        qBL = 1 + pBL;
      }

    // generate prime p

     // (pBL-2+7)/8
      SecureVector<byte> buf((pBL+5)/8);
    lcg(pBL - 2,buf.begin());

    // create a BigInteger p
    p = BigInt(buf.begin(),(pBL+5)/8);

    // shift left: the LSB is set explicitly
    p = p<<1;

    // ensure that it is a p-bit Number
    p.set_bit(pBL - 1,true);

    // and that it is odd
    p.set_bit(0,true);

    // ensure that it is congruent 3 mod 4
    if ((p%BIG4).cmp(BIG3) != 0)
      {
        p = p+BIG2;
      }


    // test for small factors
    zmod3 = (p%(BIG3)).to_u32bit();
    zmod5 = (p%(BIG5)).to_u32bit();
    zmod7 = (p%(BIG7)).to_u32bit();
    zmod11 = (p%(BIG11)).to_u32bit();
    zmod13 = (p%(BIG13)).to_u32bit();
    zmod17 = (p%(BIG17)).to_u32bit();
    zmod19 = (p%(BIG19)).to_u32bit();
    zmod23 = (p%(BIG23)).to_u32bit();

    // repeat until p is prime
    while (!is_prime(p))
      {
        add
          = 0;
        // add 4 while small factors exist:
        do
          {
            // this is cheaper than modifying the BigInteger directly (if
            // the loop is passed often)
            add
              += 4;
            // this is cheaper than using the probabilistic primality test
            // in java.math.BigInteger
            zmod3 = (zmod3 + 4) % 3;
            zmod5 = (zmod5 + 4) % 5;
            zmod7 = (zmod7 + 4) % 7;
            zmod11 = (zmod11 + 4) % 11;
            zmod13 = (zmod13 + 4) % 13;
            zmod17 = (zmod17 + 4) % 17;
            zmod19 = (zmod19 + 4) % 19;
            zmod23 = (zmod23 + 4) % 23;
          }
        while (zmod3 == 0 || zmod5 == 0 || zmod7 == 0 || zmod11 == 0
               || zmod13 == 0 || zmod17 == 0 || zmod19 == 0 || zmod23 == 0);
        // change BigInteger accordingly
        p=p+BigInt((u64bit)add
                  );
      }
    //buf = new byte[(qBL+5)/8]; // (qBL-2+7)/8
      buf.grow_to((qBL+5)/8);
    // generate prime q
    do
      {
        // create q-2 bits via lcg
        lcg(qBL - 2,buf.begin());
        // and create a BigInteger q
        //q = BigInt(1, buf);
        q = BigInt(buf.begin(),(qBL+5)/8);
        // shift left: bit 0 is set explicitly
        q=q<<1;
        // make it odd
        q.set_bit(0,true);
        // ensure that it has q bits
        q.set_bit(qBL - 1,true);

        // ensure that is congruent 3 mod 4
        if ((q%BIG4).cmp(BIG3) != 0)
          {
            q = q+BIG2;
          }

        // test for small factors
        zmod3 = (q%(BIG3)).to_u32bit();
        zmod5 = (q%(BIG5)).to_u32bit();
        zmod7 = (q%(BIG7)).to_u32bit();
        zmod11 = (q%(BIG11)).to_u32bit();
        zmod13 = (q%(BIG13)).to_u32bit();
        zmod17 = (q%(BIG17)).to_u32bit();
        zmod19 = (q%(BIG19)).to_u32bit();
        zmod23 = (q%(BIG23)).to_u32bit();

        // repeat until q is prime
        while (!is_prime(q))
          {
            add
              = 0;
            // add 4 while small factors exist:
            do
              {
                add
                  += 4;
                zmod3 = (zmod3 + 4) % 3;
                zmod5 = (zmod5 + 4) % 5;
                zmod7 = (zmod7 + 4) % 7;
                zmod11 = (zmod11 + 4) % 11;
                zmod13 = (zmod13 + 4) % 13;
                zmod17 = (zmod17 + 4) % 17;
                zmod19 = (zmod19 + 4) % 19;
                zmod23 = (zmod23 + 4) % 23;
              }
            while (zmod3 == 0 || zmod5 == 0 || zmod7 == 0 || zmod11 == 0 || zmod13 == 0 || zmod17 == 0 || zmod19 == 0
                   || zmod23 == 0);
            q = q+BigInt(add
                        );
          }
      }
    // repeat until q!= p
    while (q.cmp(p) == 0);
    // n = q * p
    n = p*q;


    // create seed for the BBS
    buf.grow_to(n.bytes());
    do
      {
        lcg(n.bits(),buf.begin());
        x = BigInt(buf.begin(),n.bytes())%n;
      }
    while ((x.cmp(BigInt(0)) == 0) || (x.cmp(p) == 0) || (x.cmp(q) == 0));

    parametersGenerated = true;

  }

}
